{% extends "layout.twig" %}

{% block title %}
Weak ordering graph of coxeter group $W = {{ group.name | default('-') }}$ with automorphism $\theta = 
{% for transposition in automorphism.transpositions %}
    (s_{{ transposition[0] }} s_{{ transposition[1] }})
{% else %}
    \textrm{id}
{% endfor %}
$
{% endblock %}

{% block content %}
<div id="canvas"></div>
<script type="text/javascript">


WeakOrderingLayout = function(graph) {
    this.graph = graph;
    this.layers = [];
    this.layout();
};

WeakOrderingLayout.prototype = {
    get: function (twistedLength) {
        if (this.layers.length < twistedLength + 1) {
        	this.layers.length = twistedLength + 1;
        }

        if (!this.layers[twistedLength]) {
            this.layers[twistedLength] = 1;
            return 0;
        } else {
            return this.layers[twistedLength]++;
        }
    },
    layout: function () {
        for (i in this.graph.nodes) {
            var node = this.graph.nodes[i];
            node.layoutPosX = node.twistedLength;
            node.layoutPosY = this.get(node.twistedLength);
            node.layoutForceX = 0;
            node.layoutForceY = 0;
        }
        
        this.layoutCalcBounds();
    },
    layoutCalcBounds: function() {
        var minx = Infinity, maxx = -Infinity, miny = Infinity, maxy = -Infinity;

        for (i in this.graph.nodes) {
            var x = this.graph.nodes[i].layoutPosX;
            var y = this.graph.nodes[i].layoutPosY;
            
            if(x > maxx) maxx = x;
            if(x < minx) minx = x;
            if(y > maxy) maxy = y;
            if(y < miny) miny = y;
        }

        this.graph.layoutMinX = minx-0.1;
        this.graph.layoutMaxX = maxx+0.1;
        this.graph.layoutMinY = miny-0.1;
        this.graph.layoutMaxY = maxy+0.1;
    }
};

$(function () {
	$.ajax('/weakordering/{{ group.id }}/{{ automorphism.id }}/graph.json', {
		'dataType': 'json',
		'method': 'GET',
		success: function (data) {
			if (data === false) {
				$('#canvas').html('Weak ordering has not been calculated yet!');
				return;
			}
			
			var g = new Graph();
			
		    var render = function(r, n) {
	            var set = r.set().push(
	                /* custom objects go here */
	                r.rect(n.point[0]-30, n.point[1]-13, 60, 44).attr({ fill: '#feb', r: '12px', 'stroke-width': '1px' })).push(
	                r.text(n.point[0], n.point[1] + 10, (n.label || n.id)));
	            return set;
	        };
			
			for (var i = 0; i < data[1].length; i++) {
				g.addNode(data[1][i][0], { render:render, label: data[1][i][0].replace(/[s|\*]/gi,''), twistedLength: data[1][i][1] });
			}
			
			for (var i = 0; i < data[2].length; i++) {
				g.addEdge(data[1][data[2][i][0]][0], data[1][data[2][i][1]][0], { label: data[0][data[2][i][2]].replace(/[s|\*]/gi,'') });
			}
			
			var layouter = new Graph.Layout.Spring(g);
			var layouter = new WeakOrderingLayout(g);
		    var renderer = new Graph.Renderer.Raphael('canvas', g, 800, 600);

		    redraw = function() {
		        layouter.layout();
		        renderer.draw();
		    };
		    
		    renderer.draw();
		},
		error: function (err) {
			alert(err);
		}
	});
});
</script>
{% endblock %}